üìå Leetcode Daily ‚Äì 16 January 2026

‚ùì Problem Statement:
2975. Maximum Square Area by Removing Fences From a Field


üìù Difficulty:
‚≠ê Medium


## ü§ù Support
Want to Support a POTD or solution?  
Way1: http://buymeacoffee.com/karthikverma
Way2: https://ko-fi.com/karthikverma


## üîó Connect With Me
- üì∫ YouTube: https://www.youtube.com/channel/UCUUPCqRPzEsX-KgM8i7E8Dg
- üîó Campus Prepp Website: https://campusprepp.myinstamojo.com/


‚≠ê **Star this repo if it helps you!**


üß† Solution:
=========================Java Solution====================================
class Solution {
  public int maximizeSquareArea(int m, int n, int[] hFences, int[] vFences) {
    final int MOD = 1_000_000_007;

    hFences = Arrays.copyOf(hFences, hFences.length + 2);
    vFences = Arrays.copyOf(vFences, vFences.length + 2);

    hFences[hFences.length - 2] = 1;
    hFences[hFences.length - 1] = m;
    vFences[vFences.length - 2] = 1;
    vFences[vFences.length - 1] = n;

    Arrays.sort(hFences);
    Arrays.sort(vFences);

    Set<Integer> hGaps = getGaps(hFences);
    Set<Integer> vGaps = getGaps(vFences);
    int maxGap = -1;

    for (final int hGap : hGaps)
      if (vGaps.contains(hGap))
        maxGap = Math.max(maxGap, hGap);

    return maxGap == -1 ? -1 : (int) ((long) maxGap * maxGap % MOD);
  }

  private Set<Integer> getGaps(int[] fences) {
    Set<Integer> gaps = new HashSet<>();
    for (int i = 0; i < fences.length; ++i)
      for (int j = 0; j < i; ++j)
        gaps.add(fences[i] - fences[j]);
    return gaps;
  }
}


===========================Python Solution=================================
class Solution:
  def maximizeSquareArea(
      self,
      m: int,
      n: int,
      hFences: list[int],
      vFences: list[int],
  ) -> int:
    hFences = sorted(hFences + [1, m])
    vFences = sorted(vFences + [1, n])
    hGaps = {hFences[i] - hFences[j]
             for i in range(len(hFences))
             for j in range(i)}
    vGaps = {vFences[i] - vFences[j]
             for i in range(len(vFences))
             for j in range(i)}
    maxGap = next((hGap
                  for hGap in sorted(hGaps, reverse=True)
                  if hGap in vGaps), -1)
    return -1 if maxGap == -1 else maxGap**2 % (10**9 + 7)


===========================C++ Solution====================================
class Solution {
 public:
  int maximizeSquareArea(int m, int n, vector<int>& hFences,
                         vector<int>& vFences) {
    constexpr int kMod = 1'000'000'007;

    hFences.push_back(1);
    hFences.push_back(m);
    vFences.push_back(1);
    vFences.push_back(n);

    ranges::sort(hFences);
    ranges::sort(vFences);

    const unordered_set<int> hGaps = getGaps(hFences);
    const unordered_set<int> vGaps = getGaps(vFences);
    int maxGap = -1;

    for (const int hGap : hGaps)
      if (vGaps.contains(hGap))
        maxGap = max(maxGap, hGap);

    return maxGap == -1 ? -1 : static_cast<long>(maxGap) * maxGap % kMod;
  }

 private:
  unordered_set<int> getGaps(const vector<int>& fences) {
    unordered_set<int> gaps;
    for (int i = 0; i < fences.size(); ++i)
      for (int j = 0; j < i; ++j)
        gaps.insert(fences[i] - fences[j]);
    return gaps;
  }
};


=========================JavaScript Solution==============================
class Solution {
    maximizeSquareArea(m, n, hFences, vFences) {
        const MOD = 1_000_000_007;

        // Add boundaries
        hFences.push(1, m);
        vFences.push(1, n);

        // Sort fences
        hFences.sort((a, b) => a - b);
        vFences.sort((a, b) => a - b);

        // Get all possible gaps
        const hGaps = this.getGaps(hFences);
        const vGaps = this.getGaps(vFences);

        let maxGap = -1;

        // Find largest common gap
        for (const gap of hGaps) {
            if (vGaps.has(gap)) {
                maxGap = Math.max(maxGap, gap);
            }
        }

        if (maxGap === -1) return -1;

        return (BigInt(maxGap) * BigInt(maxGap)) % BigInt(MOD);
    }

    getGaps(fences) {
        const gaps = new Set();

        for (let i = 0; i < fences.length; i++) {
            for (let j = 0; j < i; j++) {
                gaps.add(fences[i] - fences[j]);
            }
        }

        return gaps;
    }
}


Company Asked: 
Atlassian